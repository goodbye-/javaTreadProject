1.2.1 同步(Synchronous)和异步(Asynchronous)
             同步和异步通常用来形容一次方法的调用。
             同步方法一旦开始，调用者必须等到方法调用返回后。才能继续后续的行为。
             异步方法更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。异步方法通常会在另外一个线程中真实的执行
    
1.2.2 并发(Concurrency)和并行(Parallelism) 
               并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。
               并行 是真正意义上的同时执行    
               
1.2.3 临界区表示一种公共资源或者共享数据，可以被多个线程使用。但是每一次，只能有一个线程使用它，一旦临界区资源被占用，
                其他线程要想使用这个资源，就必须等待。            
                
1.2.4 阻塞(Blocking)和非阻塞(Non-Blocking)
        阻塞和非阻塞通常用来形容多线程间的相互影响。比如一个线程占用了临界区资源，那么其他需要这个资源的线程就只能等待，导致线程挂起。
        非阻塞的意思与之相反，他强调没有一个线程可以妨碍其他线程的执行，所有线程都会尝试不断的前向执行。
        
1.2.5  死锁、饥饿、活锁

1.2 并发级别              阻塞，无饥饿，无障碍，无锁，无等待

1.3-1.4 两个定律，出发点不一样

1.5 JMM 多线程的原子性，可见性和有序性
    
1.5.1 原子性
    long,double    32位jvm中不是原子性的

1.5.2 可见性
    某个线程将数据副本存放在cache或者寄存器中，导致其他线程的修改看不到

1.5.3 有序性  指令重排序的锅，在单线程没问题，多线程可能出现问题

1.5.4 哪些指令不能重排：happen-before规则

2 java 并行程序基础
  
  2.2.1.stop方法会直接终止线程，并且会立即释放这个线程所持有的锁，会导致数据的不一致，所以废弃，可以通过设置标志位，在进入锁之前判断是否结束。
  
  2.2.3 线程中断
        严格的讲，线程中断并不会使线程立即退出，而是给线程发送一个通知，告诉目标线程，有人希望你退出啦，至于目标线程借到通知后如何处理，则完全由目标线程自行决定。
        如果终端后，线程立即无条件退出，就会和stop一样的问题。
        与线程中断有关的，有三个方法:
        1.void Tread.interrupt() //中断线程 ; 通知目标线程中断，设置中断标志位，但是并不会真的退出，只是标识了中断；配合第二个方法实现退出
            Tread.sleep() throws InterruptedException--checkedException ,当线程在sleep休眠时，如果被中断，这个异常就会产生
            sleep方法由于中断抛出异常，会清除中断标记
        2.boolean Tread.isInterrupted() //判断是否被中断
        3.static boolean Thread.interrupted() //判断是否被中断，并清除当前中断状态

2.2.4  等待和通知  wait(必须在synchronized语句中执行obj.wait()) and  notify(在等待队列中随机唤醒，不公平)  源自object方法，算是object的锁吧

2.2.5 挂起和继续执行  suspend(虽然挂起了，但是不释放锁，而且状态还是runnable，如果resume以外的发生在它之前，那就永远无法解锁了) and resume  已废弃
            所以可以用wait实现
            
2.2.6 等待线程结束和谦让  join and yield            






